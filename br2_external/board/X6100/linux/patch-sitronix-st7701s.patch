diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index af1402d83d51..a2d6f56fdc5e 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -509,6 +509,14 @@ config DRM_PANEL_SITRONIX_ST7701
 	  ST7701 controller for 480X864 LCD panels with MIPI/RGB/SPI
 	  system interfaces.

+config DRM_PANEL_SITRONIX_ST7701S
+	tristate "Sitronix ST7701S panel driver"
+	depends on GPIOLIB && OF && SPI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y here if you want to enable support for the Sitronix
+	  ST7701S controller for LCD panels like the Jinglitai JLT4013A.
+
 config DRM_PANEL_SITRONIX_ST7703
 	tristate "Sitronix ST7703 based MIPI touchscreen panels"
 	depends on OF
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index c8132050bcec..3133c43539fe 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_DRM_PANEL_SHARP_LQ101R1SX01) += panel-sharp-lq101r1sx01.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LS043T1LE01) += panel-sharp-ls043t1le01.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7701) += panel-sitronix-st7701.o
+obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7701S) += panel-sitronix-st7701s.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7703) += panel-sitronix-st7703.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7789V) += panel-sitronix-st7789v.o
 obj-$(CONFIG_DRM_PANEL_SONY_ACX424AKP) += panel-sony-acx424akp.o
diff --git a/drivers/gpu/drm/panel/panel-sitronix-st7701s.c b/drivers/gpu/drm/panel/panel-sitronix-st7701s.c
new file mode 100644
index 000000000000..dab8de1fb67f
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-sitronix-st7701s.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for the Jinglitai JLT4013A LCD Panel, or others using the
+ * Sitronix ST7701S controller.
+ *
+ * Copyright (C) Rui Oliveira 2022
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_device.h>
+#include <drm/drm_connector.h>
+#include <linux/spi/spi.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+
+static const struct of_device_id st7701s_of_match[] = {
+	{ .compatible = "sitronix,st7701s" },
+	{ .compatible = "jinglitai,jlt4013a" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, st7701s_of_match);
+
+// DTB that we found for this driver,
+// from the Xiegu X6100
+// panel@0
+// {
+//  compatible = "jinglitai,jlt4013a";;
+//  reg = <0x00>;
+//  power-supply = <0x1b>;
+//  reset-gpios = <0x45 0x00 0x0b 0x01>;
+//  dcx-gpios = <0x45 0x00 0x0a 0x01>;
+//  backlight = <0x46>;
+//  spi-max-frequency = <0x186a0>;
+//
+//  port {
+//        endpoint {
+//                  remote-endpoint = <0x47>;
+//                  phandle = <0x0c>;
+//       };
+//  };
+// };
+
+struct st7701s {
+	struct drm_panel panel;
+	struct spi_device *spi;
+	struct gpio_desc *reset;
+	struct regulator *supply;
+};
+
+static inline struct st7701s *panel_to_st7701s(struct drm_panel *panel)
+{
+	return container_of(panel, struct st7701s, panel);
+}
+
+static int st7701s_prepare(struct drm_panel *panel)
+{
+	struct st7701s *ctx = panel_to_st7701s(panel);
+
+	int ret = regulator_enable(ctx->supply);
+	if (ret == 0) {
+		msleep(120);
+	}
+	return ret;
+}
+
+static int st7701s_unprepare(struct drm_panel *panel)
+{
+	struct st7701s *ctx = panel_to_st7701s(panel);
+
+	int ret = regulator_disable(ctx->supply);
+
+	return ret;
+}
+
+// This is essentially the display mode of the Jinglitai JLT4013A.
+static const struct drm_display_mode st7701s_default_display_mode = {
+	.clock = 14616,
+	.hdisplay = 480,
+	.hsync_start = 480 + 32,
+	.hsync_end = 480 + 32 + 11,
+	.htotal = 480 + 32 + 11 + 2,
+	.vdisplay = 800,
+	.vsync_start = 800 + 54,
+	.vsync_end = 800 + 54 + 41,
+	.vtotal = 800 + 54 + 41 + 33,
+	.width_mm = 52,
+	.height_mm = 86,
+};
+
+static int st7701s_get_modes(struct drm_panel *panel,
+			     struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	static const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	mode = drm_mode_duplicate(connector->dev,
+				  &st7701s_default_display_mode);
+	if (mode == NULL) {
+		dev_err(panel->dev, "Failed to add default mode\n");
+		return -EAGAIN;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	connector->display_info.bpc = 8;
+	connector->display_info.bus_flags = DRM_BUS_FLAG_PIXDATA_DRIVE_POSEDGE;
+
+	drm_mode_probed_add(connector, mode);
+	drm_display_info_set_bus_formats(&connector->display_info, &bus_format,
+					 1);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs st7701sfuncs = {
+	.prepare = st7701s_prepare,
+	.unprepare = st7701s_unprepare,
+	.get_modes = st7701s_get_modes,
+};
+
+static int st7701s_probe(struct spi_device *spi)
+{
+	struct device *dev;
+	struct st7701s *ctx;
+	int err;
+
+	dev = &spi->dev;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (ctx == NULL) {
+		return -EAGAIN;
+	}
+
+	ctx->spi = spi;
+	spi_set_drvdata(spi, ctx);
+
+	ctx->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ctx->supply)) {
+		dev_err(dev, "Failed to get power supply\n");
+		return PTR_ERR(ctx->supply);
+	}
+
+	ctx->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset)) {
+		dev_err(dev, "Failed to get reset GPIO\n");
+		return PTR_ERR(ctx->reset);
+	}
+
+	drm_panel_init(&ctx->panel, dev, &st7701sfuncs, DRM_MODE_CONNECTOR_DPI);
+
+	err = drm_panel_of_backlight(&ctx->panel);
+	if (err)
+		return err;
+
+	drm_panel_add(&ctx->panel);
+
+	return 0;
+}
+
+static int st7701s_remove(struct spi_device *spi)
+{
+	struct st7701s *ctx = spi_get_drvdata(spi);
+
+	drm_panel_remove(&(ctx->panel));
+	return 0;
+}
+
+static struct spi_driver st7701s_driver = {
+	.probe		= st7701s_probe,
+	.remove		= st7701s_remove,
+	.driver		= {
+		.name	= "st7701s",
+		.of_match_table = st7701s_of_match,
+	},
+};
+module_spi_driver(st7701s_driver);
+
+MODULE_DESCRIPTION("Driver for ST7701S-based LCD panels, used in the JLT4013A");
+MODULE_LICENSE("GPL v2");
